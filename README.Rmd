---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
data(df)
data(dict_df)
data(df_missing)
data(dict_df_missing)
```

# STATAtransfer

<!-- badges: start -->
<!-- badges: end -->

STATAtransfer provides functions to easily add STATA-style variable and cell labels to entire datasets in R. It also includes tools for quick variable recoding, making it easier to work with labeled data and streamline workflows between STATA and R.

## Installation

You can install the development version of STATAtransfer from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("StringhiniLab/STATAtransfer")
```

## Use

This package consists of three functions. 

### 1. `recode_vars()`. 
Many datasets, such as CLSA, use numeric codes for categorical variables. This can make it harder to label axes when you want to produce many plots or to interpret the data at a glance. 
This function replaces all numeric category values in the data frame with their corresponding labels, making the data easier to read and visualize.
For example, if we want to plot the last three variables of this dataset:
```{r example, warning=FALSE, message=FALSE}
library(STATAtransfer)
library(dplyr)
library(ggplot2)
library(purrr)
head(df)
```
```{r}

# Function for plotting
barplot <- function(var, data = df){
data |> 
count(!!sym(var)) |> 
ggplot(aes(x = !!sym(var), y = n)) +
  geom_col() + 
  coord_flip() +
  theme_minimal()
}

# I create plots for three variables
purrr::map(colnames(df)[4:6], barplot)
```
The category levels of each variable are not possible to recognize. To fix this, you can use `recode_vars` to replace the labels directly, using the dictionary as a reference.

```{r}
# dictionary
head(dict_df)

# recoding the variables
df_recoded <- recode_vars(data = df,
            # specify here other numeric columns you would like to ignore
            ignore_columns = c(id, age), 
            dictionary = dict_df,
            # dictionary column with the variable names
            var_colname = variable, # dictionary column with the variables
            # dictionary column with the category numbers
            num_colname = level_num,
            # dictionary column with the category labels
            str_colname = level_str)
head(df_recoded)
```
```{r}
purrr::map(data = df_recoded, colnames(df_recoded)[4:6], barplot)
```

### 2. `replace_missing_with_na()`

This function reads the dictionary and detects observations that are coded as missing. These missing values are represented numerically, with values like -99, which are clearly not valid results.

Databases such as CLSA, encode these missing values  distinguishing the reasons for the missing data and assigning different numeric codes to each case.
It is not the same to say that the person preferred not to answer the survey as it is to say that the survey was never conducted.
This means that there are many numeric codes that can represent a missing value.

The goal of this function is to convert all of the missing values of the categorical variables coded as numbers of a data frame to `NA`. This makes it much easier to detect the total amount of missing data per variable, regardless of the origin of the missing values.

```{r}
# There are missing values in blood_pressure_category and cholesterol_level
df_missing
```
```{r}
df_missing_NA <-  replace_missing_with_na(dataset = df_missing,
                         ignore_columns = c(id, age),
                         dictionary = dict_df_missing,
                         var_colname = variable,
                         num_colname = level_num,
                         missing_colname = missing)

df_missing_NA
```

Now, let's estimate the percentage of data that is missing.

```{r}
# 2 of 10 observations are missing for cholesterol_level (20%)
# 1 of 10 observations are missing for blood_pressure_category (10%)
colMeans(is.na.data.frame(df_missing_NA))*100
```

